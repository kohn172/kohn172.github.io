---
layout: post
title:  "熊仔的高效抉择问题"
categories: 算法基础
tags:  算法 数据结构 练习 MITOpenCourseWare
---

* content
{:toc}

## 问题描述

假设你是一只熊，你面前有一条由比目鱼组成的队伍，这些比目鱼是你的晚餐，你要在比目鱼上涂抹蜂蜜才能吃掉它们。但是这条队伍里有些狡猾的比目鱼是肚皮朝上的，有些老实的比目鱼则是背部朝上。

![bimuyu.png](https://kohn172.github.io/images/bimuyu.png)

你是一只美食家熊仔，你必须看到这一队列里所有的比目鱼都用同一个面朝上，你才肯顺利的涂抹蜂蜜。

所有的比目鱼只能听懂一个命令：”翻个面“。但所幸每个比目鱼都知道自己在队列里的位置，从第0号比目鱼开始，你可以对整条队列说：

```
第i号比目鱼，翻个面！
第i号到第j号比目鱼（包括第j号），翻个面！
```
我们该怎么下达最少的命令来让这条队列里所有的比目鱼都变成同一个面朝上？

## 解决思路

**详细解释一下这个问题** 

比如说问题中的这队鱼是这个样子的

![bimuyu2.png](https://kohn172.github.io/images/bimuyu2.png)

队伍里有7只比目鱼，从第0号到第6号，里面有4只肚皮朝上（白色），3只背部朝上，如果我们对着每一只肚皮朝上的比目鱼下达“翻个面”的命令，一共需要下达4次命令才能使队伍变成我们想要的样子。

根据规则，我们只希望全部的比目鱼同一个面朝上，这个朝上的面是背部或是肚皮并不影响最终的结果，那么如果我们让队伍中背部朝上的比目鱼“翻个面”，只需要下达3次命令就可以了。

虽然第二种策略比第一种要少1次命令数，但依然不理想，细心的我们会发现队伍中第3号和第4号比目鱼是并列出现背部朝上的情形的，那也意味着，熊仔可以：
```
第1号比目鱼，翻个面！ #1
第3号和第4号比目鱼，翻个面！ #2
```

只需要两次命令就可以达到我们的要求，现在我们把这种策略推广到数量为n的队列中。首先我们需要一个扫描器从第0号开始一直遍历到第n+1号，该扫描器需要检查第i号比目鱼的正反状态和第i+1号比目鱼的状态是否相同，如果相同，则继续扫描第i+2个，依次类推，直到第i+j号比目鱼与i的状态不同为止，我们将这一组结果构造成一个tuple，其中包含三个元素：

```
fish_tuples.append((start, end, type)) #type元素表示这组鱼的正反状态
```
当这个扫描器运行结束时，我们只要数数正反二者中哪个状态的tuple较少，就叫相应状态的比目鱼“翻个面”就好了！

## python实现
input：

```
caps = ['U', 'D', 'D', 'U', 'D', 'U', 'D', 'D', 'U', 'D', 'U', 'D', 'U'，'U', 'D', 'U', 'D', 'U' ]
```
创建一个数量为18的比目鱼队列，其中`U`表示up，即正面朝上的比目鱼，`D`表示down，即背面朝上的比目鱼

```
fish_tuples = []
start = 0
up_counts = 0
down_counts = 0
```
初始化即将用到的变量

```
caps = caps +['END']
```
为输入队列的末尾添加一个标记符

```
for i in range(1,len(caps)):
	if caps[start] != caps[i]:
		fish_tuples.append((start,i-1,caps[start]))
		if caps[start] == 'U'
			up_counts += 1
		else:
			down_counts +=1
		start = i
```
创建扫描器遍历整个队列

```
if up_counts > down_counts:
	final = "U"
else:
	final = "D"
for j in fish_tuples:
	if j[2] == final:
		print u"第",j[0],u'到',j[1],u'号比目鱼,翻个面！'
```
检查扫描器的结果来选去最终让哪种状态的比目鱼翻面并执行该策略




## 运行结果

```
第 0 到 0 号比目鱼,翻个面！
第 3 到 3 号比目鱼,翻个面！
第 5 到 5 号比目鱼,翻个面！
第 8 到 8 号比目鱼,翻个面！
第 10 到 10 号比目鱼,翻个面！
第 12 到 13 号比目鱼,翻个面！
第 15 到 15 号比目鱼,翻个面！
第 17 到 17 号比目鱼,翻个面！
```





